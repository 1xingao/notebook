
[课程连接](https://www.bilibili.com/video/BV1YE411D7nH)

## 操作系统概述

### 操作系统的四个特征

1. 并发，两个或多个时间同一时间运行，*宏观上同时发生，微观上交替进行*
  
   > 并行指的是两个或多个同时进行（非特性）

2. 共享，系统的资源同时供给多个进程共同使用  
  
   - 互斥共享  *宏观上同时发生，微观上交替进行*

   - 同时共享  在同一个时间同一设备只能分配给一个进程使用

     > 并发和共享的关系 :    互为存在条件

3. 虚拟，把物理上的实体表内若干个逻辑上的对应物，前者是实际存在的，后者是用户感受到的  
   （时分复用技术和空分复用技术）

   > 如果失去了并发性，虚拟性也没有存在的意义

4. 异步，再多到程序环境下允许多个程序并发执行，由于资源优先，进程执行私一贯到底的
  
   > 只有系统拥有了并发性才会导致异步性

### 操作系统的分类

1. 手工操作阶段

2. 批处理操作阶段  （每有人机交互功能，一直等待到程序结束，相应时间长）
  
   - 单道批处理（引入脱机输入输出技术，并且监督程序负责控制作业的输入和输出）
   - 多道批处理（引入操作系统，中断技术，各个程序并发执行）

3. 分时操作系统  (计算机以时间片为单位轮流为各个用户服务，各个用户可以通过终端与计算机进行交互)

4. 实时操作系统
  
   - 硬实时操作系统（必须绝对严格规定时间内完成处理）
   - 软实时操作系统（能接受偶尔违反时间规定）
   - 可以优先相应紧急任务

5. 网络操作系统，分布式操作系统，个人计算机操作系统

### 操作系统的运行机制和体系结构

### 运行机制

1. 指令分为特权（不允许用户执行）指令和非特权指令

2. 处理器有两种状态（用户态和核心态），用户态只能窒息感非特权指令，核心态可以执行所有指令

3. 程序分为内核程序和应用程序（内核程序可以使用核心态）

### 操作系统内核

1. 操作系统中含有内核功能和非内核功能（内核是计算机的底层软件）
  
   > 大内核包括时钟管理、中断处理、原语（设备驱动、cpu切换）|  微内核不包括进程管理、存储器管理、设备管理

![1.1_4](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/1.1_4.png)

### 中断和异常

1. 中断机制的诞生：实现多道程序并发执行，发生中断意味着需要操作系统介入管理工作

2. 中断发生时，cpu进入核心态，当前进程暂停运行，操作系统进行中断处理，对于不同的中断信号进行不同处理（进程切换，I/O设备）

> 有了中断才能实现多道程序并发执行
> 用户态->核心态只能通过中断，核心态->用户态执行特权执行，切换状态字（psw）完成

1. 中断的分类
  
   - 内中断（异常，例外，陷入）来源是cpu内部与当前执行的指令有关
     - 自愿中断（指令中断）
     - 强迫中断（硬件故障，软件中断）
   - 外中断（中断） 来源cpu外部
     - 外设请求（i/o设备完成）
     - 人工干预（用户强制终止进程）

2. 外中断的处理过程
  
   1. 每条指令执行结束后，cpu检查是否有外部中断信号
   2. 若有外部中断信号，则需要保护中断进程cpu环境
   3. 根据中断信号转入相应的中断处理程序
   4. 回退源程序的cpu环境退出中断，源程序继续执行

![1.5](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/1.5.png)

### 系统调用

1. 命令接口和程序接口

2. 操作系统提供系统调用，用户只能使用系统调用发出计算机资源请求，操作系统会对各个请求协调管理，保证系统的稳定性和安全性

3. 系统调用分类
  
   - 设备管理
   - 文件管理
   - 进程控制
   - 进程通信
   - 内存管理

4. 系统调用只能在核心态下运行，系统调用属于内核功能

5. 涉及到调用系统资源的函数才是系统调用

6. 部分库函数本质就是封装好的系统调用

7. 系统调用会使处理去从用户态进入核心态

![1.1_6](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/1.1_6.png)

------

## 进程

### 进程的组成

> 程序就是一个指令序列

1. 进程控制块（pcb）一种数据结构
2. 程序段，数据段，pcb三部分组成进程实体
3. pcb使进程存在的唯一标识
   1. 进程是程序一次执行过程
   2. 进程是一个程序及其数据在处理机上顺序执行所发生的的活动
   3. 进程是具有独立功能的程序在数据集合上的运行过程，他是系统纪念性资源分配和调度的一个独立单位

> 强调的是进程的动态性  
>
> 进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位

1. 程序段存放程序代码，数据段存放程序运行时使用，产生的运算数据，操作系统通过pcb来进行管理进程，存放操作系统用于进程管理的各种信息
   1. 进程描述信息
      - 进程标识符pid
      - 用户标识符uid
   2. 进程控制和管理信息
      - 进程当前状态
      - 进程优先级
   3. 资源分配清单
   4. 处理机相关信息
      - 各种寄存器值

### 进程的组织

> 讨论多个进程之间的组织方式问题

1. 链接方式
  
   - 按照进程状态将pcb分为多个队列
   - 操作系统持有指向各个队列的指针
     - 执行指针
     - 就绪队列指针
     - 阻塞队列指针（优先级高的在前面）

2. 索引方式
  
   - 根据进程状态不同建立索引表
   - 操作系统持有指向各个索引表的指针
     - 指针方式同链接方式

### 进程的特征

- 动态性，并发性，独立性，异步性，结构性

> 进程是资源分配，接受调度的基本单位

![2.1_1](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/2.1_1.png)

### 进程的状态

1. 运行态

2. 就绪态

3. 阻塞态

4. 创建态

5. 撤销态

### 线程属性

![shuxing](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/shuxing.jpg)

### 进程通信

![tongxin](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/tongxin.jpg)

### 多线程模型

![duoxiancheng](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/duoxiancheng.jpg)

### 进程控制

1. 对系统中的所有进程进行有效管理

2. 实现进程状态之间的转换

3. 原语执行期间不允许中断（特权指令）(特殊程序)
  
   - 关中断指令
   - 开中断指令

![2.1_2](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/2.1_2.png)

### 处理机调度

1. 当有一堆任务要处理的时候，由于资源有限，无法同时处理，需要某种规则来处理这个任务的顺序

2. 高级调度(作业调度)：外存和内存之间的调度，作业调入创建pcb，调出撤销pcb，调入调出只有一个
  
   - 调度何时调入内存

3. 中级调度（内存调度），引入虚拟存储技术，可将不能运行的进程调至外存等待，等具备了运行条件后重新调入。（挂起状态）

4. 低级调度（进程调度）按照方法从就绪队列中选取一个进程分配处理机

- 挂起状态

![2.2](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/1.2_4.png)

![2.2_1](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/2.2_1.png)

### 进程调度

- 非抢占方式，只允许进程主动放弃处理机

- 抢占方式，当一个进程在处理及上执行时，如果有更紧急的进程使用处理机，立刻暂停当前进程，分配进程到更紧急的任务

- 狭义的进程调度指的是从就绪队列选择一个要运行的进程

- 广义的包括进程选择和进程切换

- 进程的切换过程
  
  1. 对原来运行的进程各种数据保存
  
  2. 回复新进程的数据

![2.1_3](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/2.1_3.png)

### 调度算法的评价指标

- cpu利用率，利用率 = 忙碌时间 / 总时间

- 系统吞吐量，单位时间内完成作业的数量，系统吞吐量 = 总作业数量 / 完成时间

- 周转时间，作业被提交到完成的时间间隔，周转时间 = 作业完成时间 - 作业提交时间

> 周转时间包括作业在外存后背队列上等待作业调度时间+进程在就绪队列等待时间（低级调度） + 进程在cpu上的执行时间 + 进程等待i/o完成的时间

- 平均周转时间，各个作业周转时间之和 / 作业数

- 带权周转时间，作业周转使劲按 / 作业实际运行时间

- 等待时间，进程处于等待时间之和，等待i/o的时间不算等待时间，在外存等待时间也算

- 响应时间，从用户提交请求到首次产生响应的时间

### 调度算法

1. 先来先服务（fcfs）
  
   - 按照作业到达的顺序进行服务

   - 用于作业调度的时候考虑那个作业先到达后背队列，用于进程调度时，考虑那个进程先到达就绪队列

   - 非抢占式算法

   - 优先，公平，算法实现简单

   - 缺点，带权周转时间长的等待时间过长，对长作业有利，对短作业不利

   - 是否会导致饥饿，不会

2. 短作业优先（sjf)
  
   - 最短作业/进程优先得到服务（运行时间短优先）

   - 可用于作业调度，也可以用于进程调度，用于进程调度时称为“短进程优先算法”（spf）

   - 非抢占式算法，但有抢占式算法版本----最短剩余时间优先算法（srtn）

   - srtn，每当有进程加入就绪队列时，会引起就绪队列改变

   - “最短的”平均等待时间，平均周转时间

   - 不公平，对短作业有利，长作业有可能导致饥饿

3. 高响应比优先算法（hrrn）
  
   - 每次cpu空闲时计算响应比，响应比大的先分配

   - 响应比，（等待时间+要求服务使劲按） /要求服务时间

   - 可以进程调度，也可以作业调度

   - 非抢占式

   - 综合考虑等待时间和运行时间，集合前两种优点

   - 不会导致饥饿

     ***以上算法适用于批处理系统***

     ![2.2_4](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/2.2_4.png)

4. 时间片轮转调度算法（RR）
  
   - 公平轮流的为各个进程服务

   - 按照各个进程到达就绪队列的顺序，轮流让各个进程执行一个时间片，执行完回到就绪队列队尾

   - 用于进程调度

   - 抢占式算法，由时钟装置发出时钟中断来通知cpu时间片到了

   - 如果时间片太大，使每个车光绪都可以在一个时间片内完成，则会退回化成先来先服务调度算法

   - 时间片太小会导致进程切换频繁，系统会花费大量时间处理进程切换

   - 响应快，适用于分时操作系统，公平

   - 高频率的进程切换具有一定开销，不区分紧急程度

   - 不会导致饥饿

5. 优先级调度算法
  
   - 为每一个进程/作业设置一个优先级，调度时选择优先级最高的

   - 可用于进程调度，也可以用于作业调度，也会使用在i/o调度上

   - 有抢占式，也有非抢占式

   - 就绪队列不是只有一个，可以动态调整就绪队列也可以有多个不同优先级的队列

   - 根据偶县级是否可以动态改变分为，动态优先级和静态优先级

   - 设置优先级

     - 系统进程优先级高于用户进程

     - 前台进程优先级高于后台进程

     - 操作系统更偏好i/o型进程（i/o繁忙型进程）（优先让i/o设备投入工作会提高资源利用率）

       > 与之相对的叫做计算型进程（cpu繁忙型进程）

     - 动态优先级的时候什么时候调整优先级

       - 如果一个进程等待了很久会优先

       - 如果进程运行了很久会降低优先级

       - 频繁进行i/o操作优先级提高

   - 用于优先级区分紧急程度，适用于实时操作系统

   - 会发生饥饿（频繁有高优先级进程到达）

6. 多级反馈队列调度算法
  
   - 对其他调度算法折中权衡

   - 抢占式算法

   - 算法细节

     - 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大

     - 新进程到达先进入一级队列，若用完时间片为结束进程则会进入下一级队尾

     - 只有k级队列为空，才会为k+1队列头分配时间片

     - 当到达一个优先级更高的进程，运行态进程会回到原队列队尾而不是下一级队列

     - 如果进程已经在最低级队列时，完成时间片返回低级队列

   - 每个新到达的进程可以快速得到相应，算进程可以在较少时间完成，可以灵活调整对各类i昵称的偏好程度（i/o进程运行后回到原队列）

   - 可能会导致饥饿

![2.2_5](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/2.2_5.png)

***适用于交互式系统***

### 进程同步

- 讨论解决进程异步的问题

- 同步也称为直接制约关系，未完成某种任务而建立的两个或者多个进程，这些基础南横因需要在某些位置上协调工作次序而产生的制约关系

### 进程互斥

1. 把一个时间段内只允许一个进程使用的资源的称为临界资源

2. 对于临界资源的访问，必须互斥进行

3. 对于临界资源的互斥访问
  
   - 进入区（检查是否可以进入临界区），可以进入则会设置正在访问资源的标志（上锁）

   - 临界区，访问资源的代码

   - 退出区，解除正在访问资源标志（解锁）

   - 剩余区，其他处理

   - 为了保证系统的整体性能应该遵顼一下规则

     - 空闲让进

     - 忙则等待

     - 有限等待，保证有限时间内进入临界区，不会导致饥饿

     - 让权等待，当进程不能进入临界区，应该放弃处理机。防止进程忙等待

![2.2_6](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/2.2_6.png)

### 进程互斥的实现方法

![ruanjian](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/jinchengruanjian.jpg)

![yingjian](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/jinchengyingjian.jpg)

### 信号量机制

1. 之前的互斥的实现方法都无法实现让权等待，部分在进入区和临界区之间无法一气呵成  
   进程调度会改变

2. 信号就是一个变量，可以用一个信号量表示系统中某种资源的数量

3. 原语，特殊程序段，执行只能一气呵成，本次使用的是wait和signal原语或者叫P，V

#### 整形信号量

1. 用一个整型变量作为信号量，表示当前系统中某种资源数量

2. 与普通变量区别是信号量只能进行初始化，P，V

```cpp
   int s = 1;
   
   void wait(int s){
       while(s<=0);
       s = s-1;
   }
   
   void signal(int s){
       s= s+1;
   }
   
   //进程p0
   wait(s);//进入区
   //使用打印机资源//临界区
   signal(s);//退出区
```

3. 其他进程执行while循环会导致忙等，整型信号量机制不满足让权等待

#### 记录型信号量

```cpp
typedef struct{
    int value;//剩余资源数
    struct process *l;//等待队列
}semaphore;

void wait(semaphore s){
    s.value--;
    if(s.value< 0){
        block(s.l);
    }
}

void signal(semaphore s){
    s.value++;
    if(s.value <=0){
        wakeup(s.l);
    }
}
```

1. block原语，当剩余资源不够的时候会使运行态的进入阻塞态，并且挂到信号量s的等待队列中

2. wakeup原语，释放资源后若还有其他进程等待资源，则会使用wakeup唤醒等待队列的一个进程，从阻塞到就绪队列

![2.3_4](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/2.3_4.png)

### 信号量机制实现进程互斥

1. 分析并发进程的关键活动，划定临界区

2. 设置互斥信号量mutex，初始值为1

3. 临界区之前执行P(mutex)

4. 临界区后执行V(nutex)

5. 对于不同的临界i资源需要设置不同的互斥信号量

6. pv操作成对存在

### 信号量机制实现进程同步

> 进程同步保证各个进程有顺序的执行

1. 分析什么地方需要实现同步关系，确定一前一后关系

2. 设置同步信号量是，初始值为零

3. 在前操作之后执行V

4. 在后操作之前执行P

5. 同步信号量初始值为零

### 信号量机制实现前驱关系

![2.3_5](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/2.3_5.png)

> 实现互斥在实现同步之后，不然会导致死锁
> 临界资源等于一的时候可以不设置互斥信号量

#### 读写问题的互斥和同步

使用计数器变量来表示当前访问的进程数量实现同时读取文件

![2.3_9](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16622797175991662279717207.png)

但是如果有源源不断的读进程进入的时候会导致写进程饿死

新加一个互斥信号量用于实现写优先

![2.3_9_2](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16622798996001662279898946.png)

#### 哲学家进餐问题

一个进程同时需要两个以上的临界资源访问

![2.3_10](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16622808266001662280825872.png)

### 管程

> 一种高级同步机制

#### 管程是一种特殊的软件模块，有这些组成

1. 局部于广成的共享数据结构说明
2. 对该数据结构进行操作的过程（函数）
3. 对局部于管程的共享数据设置初始值的语句
4. 管程有一个名字

#### 管程的基本特征

1. 局部与管程的数据只能被局部于管程的过程访问
2. 一个进程只有通过调用管程内的过程才能进入管程访问共享数据
3. 每次仅允许一个进程在管程内执行某个内部过程

#### 管程的实现

![2.3_11](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16622817767011662281776649.png
)

### 死锁

死锁： 在并发环境下，个进程因为竞争资源造成的一种互相等待对方手里资源，导致各个进程都在阻塞，无法向前推进的现象

饥饿 ： 由于长时间得不到自己想要的资源，某进程无法向前推进的xianx

#### **死锁产生的条件**

1. 互斥条件，存在互斥访问的资源争抢
2. 不可剥夺条件：在没有使用完，别人不能被其他进程强行抢走，只能主动释放
3. 请求和保持条件：已经持有一个资源，但又提出了新的资源请求
4. 循环等待资源条件： 存在一个进程的资源循环等待链

#### **什么时候会发生死锁**

1. 对系统资源的竞争
2. 进程推进顺序非法
3. 信号量使用不当

#### **死锁的处理策略**

1. 预防死锁
2. 避免死锁，使用一个算法防止系统进入死锁
3. 死锁的检测于解除

#### **预防死锁**

破坏死锁产生的四个条件

1. 互斥条件（对于必须互斥使用的资源的争抢） 将独占设备改造成**逻辑**上的共享设备（spooling技术）
2. 破坏不剥夺条件  
方案一：当一个进程请求的资源得不到满足时，必须先释放现有资源  
方案二：操作系统吸住强行剥夺

3. 破坏请求和保持条件，采用静态分配方式，在一个进程运行前一次申请完所需要的全部资源
4. 破坏循环等待他条件，顺序资源分配法，对于每一个资源编号，进程必须按照编号递增的顺序请求资源。

![2.4_2](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16624467037061662446702911.png)

#### 避免死锁

安全序列：如果系统按照序列分配资源，则每个进程都能顺利完成。只要找出一个安全序列，系统就是安全序列。

不安全状态： 系统找不到任何一个安全序列。（可能会发生死锁）

**银行家算法** ： 每次进程提出资源申请，咸鱼盘这次分配会不会导致系统进入不安全状态，如果进入不安全状态，就暂时不分配资源

![2.4_3](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16624475607051662447560338.png)

#### 死锁的检测和解除

![2.4_4](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16625499681321662549967253.png)

定义一种数据结构

1. 有向图，分为两种节点，一种进程节点，一种资源节点，资源节点显示有多少个同类资源
2. 进程节点指向资源节点代表请求多少个资源，资源节点指向进程节点表示分配给进程多少个节点
3. 死锁检测算法类似安全序列不断化简图，如果每个进程节点都可以被化简为孤点，则没有死锁
4. 化简完后还连着边的进程就是死锁进程

**死锁的解除**

1. 资源剥夺法，挂起某些死锁进程释放他所占有的资源
2. 撤销进程法，强制关闭某些死锁进程（危险方法）
3. 进程回退法，让一个或者多个进程回退到足以避免死锁的状态，要求系统记录进程的历史信息，设置还原点（难以实现）

   ------

## 内存管理

### 内存概念和作用

1. 内存适用于存放数据的硬件，执行程序前需要先放到内存中才能被cpu处理

### 逻辑地址和物理地址的转换

1. 绝对装入，直接使用物理地址
2. 静态重定位，在编译后将逻辑地址转化为物理地址
3. 动态重定位，使用重定位寄存器，在实际运行的时候才会转换，允许程序在运行时候在内存之上移动，

![3.1_1](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16630813501491663081349291.png)

### 内存管理的概念

所要实现的功能

1. os负责内存的空间分配与回收
2. os提供技术从逻辑上堆内存空间进行扩充
3. 逻辑地址到物理地址的转换
4. 内存保护，保证各个程序在自己的内存空间之间工作相互不干扰：两种方法
    - 设置上限寄存器和下限寄存器
    - 使用重定位寄存器，在装入的时候存放起始物理地址，界地址寄存器存放存放进程的最大逻辑地址（用于换算截止的物理地址）

![3.1_2](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16631612264831663161226409.png)

### 覆盖与交换（内存空间的扩充）

#### 覆盖技术（解决程序大小超过物理内存总和的技术）

- 将程序分为多个段（多个模块），内存分为一个固定区和若干个覆盖区  
- 需要常驻内存的段就放在固定区，不在调出  
- 不常用的段放在覆盖区，需要的是偶再调入内存，不需要的时候调出内存
- 让不可能同时使用的程序段共用一个覆盖区

#### 交换技术（对换）

当内存紧张的时候，系统将内存中某些进程暂时换出外存，把内存某些具备运行条件的进程换入内存（中级调度）（挂起）

1. 应该再外存的什么位置保存被换出的进程：
    - 把磁盘空间分为对换区（连续分配方式）和文件区（离散分配方式）

2. 什么时候应该交换：
    - 发生缺页

3. 应该换出那些进程：
    - 优先换出阻塞进程，优先换出优先级低的进程（有时候会考虑进程再内存的留存时间以防止优先级低的进程饥饿问题）

> 无论怎样交换进程，进程的PCB都不会被换出内存

### 内存空间的分配与回收

#### 单一连续分配方式

内存分为系统区和用户区（内存地址由低到高），内存中只有一道用户程序

优点：实现简单，无外部碎片，不需要内存保护

缺点：只能实现单用户、单任务的操作系统，会导致内部碎片

##### 固定分区分配

将用户空间划分为若干个大小的分区，分别在每个分区转入一个作业

分为 分区大小相等和不等

###### 分区大小相等

缺乏灵活性，太小用不完，太大不够，无外部碎片，有内部碎片

###### 分区大小不等

操作系统建立的数据结构，来实现各个分区分配的分配与回收（大小，起始地址，状态）

无外部碎片，有内部碎片

##### 动态分区分配

不会预先划分内存分区，在进程装入内存的时候根据进程大小动态建立分区

没有内部碎片，但有外部碎片

**内部碎片：分配给某进程的内存区域中，有些部分没有用上**

**外部碎片：内存中某些空闲内存太小难以利用**

可以通过紧凑技术解决外部碎片

###### 使用什么样的数据结构记录内存的使用情况

1. 空闲分区表

![3.1_41](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16631628072471663162806431.png)

2. 空闲分区链

每个分区起始部分和某位部分分别设置前向指针和后向指针指向对方，其实部分可能还记录着分区大小的信息

###### 当有很多空闲分区，应该选择那个分区进行分配

动态分区分配算法

###### 如何进程分区的分配与回收

更改空闲分区表的记录

###### 动态分区分配算法

###### 首次适应算法

每次从低地址开始查找，找到第一个大小能慢的大小的空闲分区

**实现**：空闲分区以地址递增的次序排列，每次分配内存时顺序查找空闲分区，找到第一个，满足要求的空闲分区

###### 最佳适应算法

由于动态分区分配是一种连续分配方式，为各个进程分配的空间必须是连续的，为了保证大进程的连续大片空间，尽可能留下更多的大片空闲区

**实现**：空闲分区按照容量递增，寻找能满足进程需要的最小空间分配，每次分配需要重新排序

缺点 ： 每次都选取最小的进行分配，会逐渐增加细小外部碎片，难以利用

###### 最坏适应算法

每次分配时优先使用最大的连续的空闲区，这样分配后剩余的空闲区不会太小凹

**实现** ： 按照容量递减怕排序，每次分配内存的时候，找到大小能满足的第一个空闲分区，分配后需要重新排序

缺点： 每次都选择最大的进行分配，会导致大进程没有足够的空间分配

###### 邻近适应算法

首次适应算法会导致低地址的位置有很多小碎片

基于首次适应算法，每次分配的时候从上次查找结束的位置查找大小能满足的第一个分区

**实现** ：将空闲分区地址递增（循环链表）每次分配从上次结束的位置开始查找

优点：算法开销小，每次分配不需要重新分配

![3.1_5](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16634059556751663405954913.png)

#### 非连续分配管理方式

##### 基本分页存储

1. 把固定分区分配方式改造为非连续的分配管理
2. 将内存空为一个个大小相等的分区，每个分区就是一个页框（页框/内存块/物理快），每一个页框有一个编号（内存块号/页帧号/物理块号），页框号从0开始
3. 操作系统以页框为单位为各个进程分配内存空间，进程的每个页面放进一个页框，进程的页面与内存的页框具有一一对应关系，各个页面不必连续存放
4. 重定位寄存器（动态重定位，获取起始地址和偏移量）
    - 算出逻辑地址对应的页号  ----  页号 = 逻辑地址 / 页面长度 （取除法整数部分）
    - 知道页号对应页面在内存的起始地址
    - 算出逻辑地址页面内的偏移量------页内偏移量 = 逻辑地址 % 页面长度 （取除法的余数部分）
    - 物理地址 = 页面地址加页内偏移量

5. 为了知道进程的页面在内存的存放位置，操作系统要为每个进程建立一样页表
    - 一个进程一个页表
    - 进程的每一页对应一个页表项
    - 每个页表项又 页号和块号组成
    - 页表记录进程页面和实际存放的内存块之间的对应关系

![3.1_6](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16636839924961663683992069.png)

###### 基本地址变换机构

系统会在系统中设置一个页表寄存器，存放页表在内存中的起始地址F和页表长度M

进程未执行的时候页表的初始地址和长度放在pcb中，进程被调度的时候操作系统会把他们放在有页表寄存器中

![3.1_7](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16639333683861663933367576.png)

###### 具有块表的地址变换机构

时间局部性：如果执行了缪个程序的某条指令，怎不久后这个条指令或者数据很可能会被再次访问

空间局部性：一旦程序访问了某个存储单元，在不久后很可能会访问其附近的存储单元

快表：联想存储器（访问速度比内存块的高速缓冲器）

![3.1_8](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16639342714001663934271117.png)

查询快表命中后不会查询页表（快表和页表结构相似）

###### 两级页表

**单级页表机制存在的问题**：一个进程的页表最大可能会需要1024的连续的页框来存储页表，没有必要让整个页表常驻内存，进程一段时间内只可能访问几个特定的页面

模仿为内存建立页表的方式，为了让页表也可以离散分布，为页表建立一个外层页表（顶层页表/页目录表）

**细节** ： 采用多级页表机制，各级页表的大小不能超过一个页面

![notice](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16639356854131663935684810.png)

##### 基本分段存储

1. 进程的地址空间：按照程序自身逻辑关系划分为若干个段，每个段都有一个段名，每段从0开始编址

2. 内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间， 各段之间可以不相邻
3. 逻辑地址组成：段号+段内地址
4. 短号的位数决定了每个进程最多可以分为多少个段，段内地址位数 决定了每个段的最大长度是多少

**段表**：组成：段号+段长+段址

**地址转换**：
![3.1_10](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16640873790931664087378237.png)

##### 分页存储和分段存储的区别

![区别](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16640877010941664087700973.png)

1. 分段比分页更容易实现信息的共享和保护
2. 实现共享只需要将各个进程的段表项指向同一个段（前提是这个段不属于临界资源）

![段表](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16640880020931664088001719.png)

##### 段页式管理方式

优点：

1. 分页管理空间利用率高，不会产生外部碎片，只会产生少量内部碎片
2. 分段管理很方便按照逻辑模块实现信息的共享和保护

缺点：

1. 分页不方便实现信息的共享和保护
2. 分段如果段过大，为其分配连续的空间很不方便，还会产生外部碎片

进程按照逻辑模块分段，再将各段分页

![段页式](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16640884250921664088424360.png)

逻辑地址：段号+（页号+页内偏移量）段内地址

分别有一个段表和多个页表
段表里面是段号——页表长度——页表存放块号
页表里面是页号——内存块号

一个进程有一个段表，一个段表对应多个页表

![3.1_11](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16640891520921664089151487.png)

### 虚拟内存

> **实现内存空间扩充的技术**

#### 传统存储管理方式的特征

1. 一次性：作业必须一次性全部装入内存后才能开始运行（无法将大作业装入内存  /   大量作业运行时无法全部装入）
2. 驻留性：一旦作业被装入，就会已知留存在内存中，知道作业运行结束（浪费内存资源）

#### 虚拟内存技术

由于局部性原理采用虚拟内存技术

![虚拟内存](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16641954300681664195430006.png)

虚拟内存的最大容量是由计算机的地址结构确定的

虚拟内存的实际容量 = min(内存外存之和，cpu寻址范围)

#### 虚拟内存的三个特征

多次性 ： 无需再作业运行时一次性全部装入内存，而是分成多次调入内存

对换性 ： 在作业运行时，无需已知常驻内训，而是允许再作业运行过程中，将作业换入，换出

虚拟性 ： 从逻辑上扩充了内存的容量，使用户看到的内存容量远大于实际容量

#### 如何实现虚拟内存技术

虚拟内存的实现需要建立在离散分配的存储管理方式

1. 请求分页管理
2. 请求分段管理
3. 请求段页式管理

区别 ; 当所访问的信息不在内存时，由操作系统负责将所需要的信息从外存调入内存，若内存孔家不足，由操作系统将内存暂时不用的信息换出外存

> 需要添加，请求调页功能，页面置换功能

#### 请求分页管理方式

##### 页表机制

页号 / 状态位（是否调入内存） / 访问字段（记录访问次数，用来供置换算法参考） / 修改位 / 外存地址

##### 缺页中断机构

![缺页中断](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16641963400141664196339390.png)

##### 地址变换

相对于基本分页存储，需要新增三个步骤

1. 请求调页（查到页表项时候判断是否在内存）
2. 页面置换（需要调入页面，但是没有空闲块时进行）
3. 需要修改请求页表中新增的表项

**快表中只保存存在于内存的页项**

![3.2_2](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16641972338831664197233159.png)

![3.2_2_1](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16641972668711664197266096.png)

#### 页面置换算法

选择需要把那个页面换出外存

缺页率 = 缺页次数 / 总的内存调用次数

##### 最佳置换算法（OPT）

**理想化算法**

每次选择淘汰的页面将是以后用不使用，或者长时间不会被访问的页面。保证最低的缺页率

##### 现进先出置换算法（FIFO）

每次淘汰的页面时最早进入内存的页面

实现：队列

**/Belady异常/**：为系统分配的物理块增大时，缺页次数不减反增的异常现象

算法性能差

##### 最近最久未使用置换（LRU）

每次淘汰最近最久未使用的页面

实现：在页表项里添加一个**访问字段**来记录上次被访问以来经历的时间t

需要专门的硬件实现，虽然算法性能高，==但是算法开销大==

##### 时钟置换算法（CLOCK）

![clock](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16642643475451664264346678.png)

##### 改进的时钟置换算法

简单时钟置换算法只考虑了一个页面是否被访问过，但是如果被淘汰的页面没有被修改，是不需要执行I/O操作写回的，只有被淘汰的页面修改过才会写回内外存

因此除了考虑一个月眠是否被访问过，os还会考虑页面有没有被修改过，在其他条件都相同时，优先淘汰未被修改过的页面

实现 ： 增加**修改位**于页表中

![改进](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16642647066651664264705801.png)

#### 页面分配策略

驻留集 ： 请求分页存储管理中给进程分配的物理块集和 ，大小一般小于进程的总大小

1. 固定分配
2. 可变分配，驻留集可以动态增加减少

3. 局部置换：发生缺页只能选择进程资金的物理块进行置换
4. 全局置换：os可以将自己保留的空闲物理块分配给缺页进程，也可以将其他进程的物理块分配给进程

5. 固定局部置换
6. 可变分配局部置换（如果os发现缺页率太高就会多分配几个物理块）
7. 可变全局置换

系统会锁定一些物理块不允许换出外存

![23.2_4](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16642655000641664265499261.png)

#### 什么时候调入页面

1. 预调页策略：局部性原理，一次调入若干个相邻的页面，主要用于进程首次调入
2. 请求调页策略，运行期间使用

#### 从何处调入页面

**对换区**/文件区

![3.2_4](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16642657956991664265794791.png)

#### 抖动

刚刚换入的页面马上就要换出，刚刚换出的又要换入

#### 工作集

在某段时间内，进程实际访问的页面集和

系统可以根据工作集大小分配驻留集的大小

---

## 文件

### 初识文件系统

文件就是一组有意义的信息和数据集和

***文件拥有的属性***：

1. 文件名
2. 标识符
3. 文件类型
4. 文件路径（文件在外存的地址，不可见）
5. 文件大小、创建时间、上次修改时间、文件所有者
6. 保护信息：对用户的文件进行访问保护

***文件内部数据怎样组织起来***：

无结构文件和有结构文件

**如何将文件组织起来**：

用户自己创建一层层的目录（目录也是一中有记录的有结构文件）

**操作系统向上提供那些功能**：创建文件（create系统调用） / 读文件（read）/ 写文件 （write）/删除文件（delete）/打开 （open）/ 关闭 （close）

**文件如何存在外存**：外存和内存一样会被分为一个个存储单元，外存被分为一个个块，每个磁盘块的大小相等，文件的逻辑地址分为   逻辑块号 + 块内地址

### 文件的逻辑结构

1. 无结构文件

   文件内部数据就是一系列二级制六或者字符流，又称为流式文件

2. 有结构文件

   又称为记录文件，每条记录又多干个数据项组成

   **每一个条记录有一个数据项作为关键字，根据长度是否相等分为可变长和定长**

   1. 顺序文件

      文件中记录一个接一个地顺序排列（逻辑上），记录可以是定长的也可以是可变长的

      记录物理上可以是顺序存储和链式存储

      串结构 和 顺序结构     (**关键是否按照顺序存储**)

      ![顺序文件](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16643696485721664369647731.png)

   2. 索引文件

      建立一张索引表加快索引文件，每条记录对应一个索引项

      索引表本身时定长记录的顺序文件（可以随机索引）

   3. 索引顺序文件

      建立的索引表，但并不是每个记录对应一个索引表项，而是每一组记录对应一个索引表项

      每组建立自己的顺序文件

      还可以建立多级索引再建立顺序文件

      ![4.1_2](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16643705566041664370556542.png)

### 文件目录

#### 文件控制块

目录本身就是一种有结构文件，又一条条记录组成，每条目录对应一个存放在该目录下的文件/目录

FCB（文件控制块）被称为文件目录，一个FCB就是一个目录项

FCB中包含了文件的

1. 基本信息：文件名 / 物理地址 / 逻辑地址 / 物理结构
2. 存取控制信息 ： 读写权限 / 禁止访问的用户名
3. 使用信息 ： 创建时间 / 修改时间

需要对目录进行那些操作：

1. 搜索
2. 创建文件
3. 删除文件
4. 显示目录
5. 修改目录

#### 目录结构

单级文件目录

- 不允许文件重名

两级目录结构

- 分为两级目录结构（主文件目录 / 用户文件目录）

多级目录结构（树形目录结构）

- 从根目录出发为绝对路径
- 从当前目录出发的叫相对路径
- 不便于实现问价共享

无环图目录结构

- 基于树形目录
- 增加一些指向同一个节点的有向边，使目录成文一个有向无环图
- 设置共享计数器用于实现被多次指向的文件的删除

#### 索引节点

> FCB的改进

在查找的时候只需要文件名进行查找，剩下的信息可以添加到索引节点

这样FCB只需要存放文件名和索引节点指针就可以

![索引节点](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16648719077731664871906885.png)

### 文件的物理结构（文件的支配方式）

- 类似于内存分页，磁盘中的存储单元也会被分为一个个块 / 磁盘块 / 物理块

在外存管理中，为了方便对文件数据的管理，文件的逻辑地址空间也被分为一个个文件的块

文件的逻辑地址（逻辑块号，块内地址）

#### 文件分配方式

1. 连续分配 ： 每个文件在磁盘上占有一组连续的块
   - 文件目录中存放的起始块号和长度（总共有几个块）
   - 物理块号 = 起始块号（FCB中） + 逻辑块号
   - 支持随机访问和顺序访问
   - 顺序读写速度最快
   - 扩展文件的大小不方便 / 对连续空闲块要求高（空间利用率低）
2. 隐式连接分配
   - 采用离散分配，使用指针连接
   - 读取起始块号和结束块号（FCB内） /  从头依次访问起始块到所需要的块号
   - 支支持顺序访问，不支持随机访问
   - 便于扩展 / 不会产生碎片问题
3. 显示链接分配
   - 用于连接文件各个物理块的指针显示存放在一张表（文件分配表）/ FAT
   - 文件分配表内是物理块号 + 指向的下一个块
   - 一个磁盘只有一张FAT，在开机的时候被读入内存而且常驻
   - 查询起始块号 ， 然后在FAT中执行链表向后访问的操作寻找需要的块
   - 支持顺序访问和随机访问
   - 地址转换过程不会有磁盘操作
4. 索引分配
   - 允许文件离散的存在磁盘块中 ， 系统为每个文件创建一个索引表，索引表中记录了文件的各个逻辑块对应的物理块（页表）
   - 存放索引表的块被称为索引块
   - FCB中是文件名 / 索引块
   - 每一个文件都有一个自己的索引表
   - 地址转换 ： 在FCB中找到索引块号，查询索引块查询外存地址加上块内地址
   - 如果一个文件的块数过多，索引条数也大于一个块
     - 链接方案： 将多个索引块链接起来
     - 多级索引（类似多级页表）
     - 混合索引：顶级索引中存在部分直接地址 / 一级间接索引表（单级索引） / 二级索引表（多级索引表）

### 文件存储空间管理

文件区分为目录区和文件区

目录去存放FCB / 用于磁盘空间管理的信息

#### 空闲表法

1. 记录空闲分区的起始位置和空闲块数
2. 适用于连续分配方式
3. 如何分配磁盘块：首次适应 / 最佳使适应 / 最坏适应 算法
4. 如何回收空闲磁盘块 ： 同内存管理

#### 空闲链表法

1. 空闲盘块链

   1. 系统会保存链头和链尾指针，从头开始一次分配
   2. 回收的开盘快依次挂到链尾

2. 空闲盘区链（多个空闲块组成一个区）

   1. 保存链头链尾
   2. 采用首次和最佳适应算法寻找满足大小的空闲盘区
   3. 若没有满足的空闲盘区，就将多个盘区分配给程序

#### 位示图法

1. 每个二进制位对应一个盘块，位0表示空闲，1表示分配

![位](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16651415538091665141552940.png)

#### 成组链接法

1. 建立超级块，超级快指向空闲块号的地址，指向的第一个空闲块号是一个记录了其他空闲块号的超级块
2. 一个超级快第一个数据是当前块记录的空闲块数
3. 分配的时候检查所需要的空闲盘块数于当前记录的空闲盘块数，小于直接将当前块记录的空闲盘快分配
4. 回收的时候从头寻找空闲盘块数还未满的块

![cheng](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16654702465261665470245717.png)

**回收**

![huishou ](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16654703905821665470390531.png)

### 文件的基本操作

1. 创建文件：调用create系统调用
   - 参数：所需的文件大小，文件存放路径，文件名
   - 在外存中寻找空闲空间
   - 根据文件存放路径找到改目录对应的目录文件
2. 删除文件：调用delete系统调用
   - 参数： 文件路径 / 文件名
   - 找到目录项
   - 释放在外存的磁盘块
   - 删除文件对应的目录项
3. 打开文件：调用open
   - 参数：文件存放路径 / 文件名 / 对文件打的操作类型（w,r,rb,wb）
   - 根据路径找到对应的目录文件并且检查是否有操作权限
   - 将目录项复制到内存中的“打开文件表”，
   - 打开文件表分为系统的和进程的，系统的只有一张
   - 系统中对有一个打开计数器（记录打开该文件的进程数）
   - 进程的打开文件表有一个系统表索引号，指向系统打开文件表，读写指针定位读写位置，访问权限
4. 关闭文件：调用close
5. 读文件：read
   - 指明需要读的文件在进程打开表中的编号
   - 读取数据数量
   - 从读写指针开始读入数量
   - 将读出的数据放入进程所指定的内存位置
6. 写文件：write
   - 指明写文件的序号
   - 数据大小
   - 写回外存的位置

![打开文件](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16654709926031665470992550.png)

**打开文件的时候不i会对文件进行读取，而是将文件放入打开文件表**

**只有读文件的时候才会将文件从外存放入内存**

### 文件共享

多个用户共享同一个文件，代表系统只有一份文件数据。

1. 基于索引节点的共享方式（硬链接）
   1. 索引节点中设置一个count变量，记录连接到索引节点的用户目录数
   2. 删除的时候会检查count数，大于等于1的时候不会真的删除
   3. 共享文件的地址（索引节点）
2. 基于符号链的共享方式（软连接）
   1. 创建一个link类文件，记录了文件1的存放路径，查找这个路径再通过这个路径访问文件1
   2. 快捷方式
   3. 共享文件的路径

### 文件保护

1. 口令保护：比对口令
2. 加密保护：使用密码进行加密，使用密码进行解密
3. 访问控制

### 文件系统的层次结构

![ceng](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16654726115351665472610874.png)

### 磁盘调度算法

#### 一次读写时间

寻找时间 = 启动磁头臂 + 移动磁头（跨越磁道耗时*总共磁道数*）

延迟时间 = 旋转磁头使磁头定位到目标扇区的时间

传输时间 = 从磁盘读出或者写入经历的时间

#### 磁盘调度算法

优化寻到时间

1. 先来先服务 : 公平，磁道集中的话算法性能还可以
2. 最短寻找时间优先 ： 优先处理的磁道是于当前磁头最近的磁道
3. 扫描算法：只有磁头移动到最外侧的时候才能往内移动，只有磁头移动到最内侧菜呢个向外移动，其他时候使用最短寻找时间
4. LOOK算法：如果扫描算法到达最边上的磁道方向没有其他请求，就会直接返回
5. 循环扫描算法 ： 只有磁头超某个特定方向移动时才能处理请求，返回时候直接返回起始段不处理
6. c-look算法：如果磁头移动方向没有任何请求就可以直接返回，磁头往回移动的时候只需要移动到最开始有请求的磁道

![cipan](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16658996271041665899626256.png)

### 磁盘的物理地址

柱面号 ， 盘面号 ， 扇区号

方便连续地址增加是不需要移动磁头，只需要读取下一个盘面，读取柱面号的性能开销大

错位命名也可以加速连续地址的读取，读取完7号扇区可以直接读取下一个盘面的零号扇区，不需要等待一圈

-----

## I/O

输入输出设备

### 分类

1. 人机交互设备，慢
2. 存储设备，快
3. 网路通信设备，中

- 低速 / 中速 / 高速设备

- 块设备 （速度快，可以寻址）/ 字符设备

### I/O控制器

i/o设备由机械部件和电子部件组成

功能：

1. 接受识别cpu的命令，控制寄存器粗放命令和参数
2. 向cpu报告设备状态，状态寄存器存放设备状态
3. 数据交换，数据寄存器
4. 地址识别

**组成**

![zucheng ](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16659016541101665901653804.png)

![dizhi ](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16659017783731665901778327.png)

### i/o控制方式

#### 程序直接控制方式

![1](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16661691750591666169174188.png)

cpu干预频率：频繁

数据传送单位 ： 一个字

数据流向： 读：i/o->cpu->内存 / 写： 内存->cpu -> i/o

优点：实现简单

缺点： cpu一直轮询检查

#### 中断驱动方式

由于i/o速度慢，在cpu发出读写指令后，将等待i/o的进程阻塞，先切换到其他进程     （中断）

cpu干预频率：i/o开始完成需要cpu介入

数据量：一个字

数据流向同直接控制方式

优点：cpu运行效率高

缺点：每次只能输入一个字

#### dma方式

> 为解决中断方式的缺点

每次传送的数据范围是块

数据流向不需要经过cpu

尽在传送一个或者多个数据块开始结束的时候，才需要cpu干预

**DMA**控制器

dr：数据寄存器

mar：内存地址寄存器

dc：数据记录器

cr：命令 / 状态寄存器

dma控制器接收到cpu的指令后，将外存中所需要的数据全部放入内存中后才会向cpu发出中断信号

 缺点：cpu发出一条指令只能读取连续的内存块

#### 通道控制方式

设置通道程序（cpu的任务清单）

告诉通道通道程序的地址，告诉通道去执行通道程序，完成后发出中断信号

通道可以识别通道指令

![tongdao ](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16661703520591666170351364.png)

### i/o软件层次结构

[其他笔记]([《王道操作系统》学习笔记总目录+思维导图_BitHachi的博客-CSDN博客_王道操作系统思维导图](https://blog.csdn.net/weixin_43914604/article/details/104415990))

![1234](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16662602360241666260235214.png)

### 缓冲区管理

话冲去就是一个存储区域，可以由硬件寄存器组成，也可以是内存

一般情况下时内存作为缓冲区

1. 单缓冲（没有其他说明，一个缓冲区就是i一个块）

   1. 缓冲区非空的时候不能写入，只能读出
   2. 缓冲区为空，不能读出，只能写入
   3. 平均耗时max(处理时间c，写入缓冲区时间t)+缓冲区传输到工作区时间m

2. 双缓冲

   1. 平均耗时t>c+m,时间为t
   2. t<c+m,c+m

3. 循环缓冲区

   1. 将多个大小相等的缓冲区组成一个循环队列

4. 缓冲池

使用缓冲区进行通信的时候

单缓冲区只能同一时刻单向传输

双缓冲区可以同时双向通信

![huanc ](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16662614380251666261437263.png)
